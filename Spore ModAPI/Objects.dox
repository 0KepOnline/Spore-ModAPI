/**

@page objects Memory management and Objects

How to deal with pointers and Objects in the SDK.

Memory management in C++ can be very annoying to deal with, so Spore and the ModAPI SDK provide some features to help you.

## Reference counting

The classes that implement the so called <b>reference counting</b> technique can be automatically managed.
A class is reference counted when it implements the following methods:
\code{.cpp}
int AddRef();
int Release();
\endcode

Most classes in the SDK are reference counted; if a class is not reference counted, you should probably not be using it.

### Intrusive pointers

Instead of using naked pointers, like <tt>IModelWorld*</tt>, reference counters must be used with <b>intrusive pointers</b>.
This will manage memory automatically: <tt>intrusive_ptr<IModelWorld></tt>. You can still use them like the naked pointers,
with the <tt>-></tt> operator; if you need to access the naked pointer (usually when passing parameters to a function), use <tt>.get()</tt>

\code{.cpp}
intrusive_ptr<App::PropertyList> propList = ...;
string str;
App::Property::GetString8(propList.get(), 0x003d9f80, str);

\endcode


### Implementing reference counting

If you create a custom class, you will probably have/want to implement reference counting. The easiest way is to just extend the 
<tt>DefaultRefCounted</tt> class, at the <tt><Spore/Object.h></tt> header. If you inherit from multiple classes, it's best to
explicitly tell the compiler that you are using its methods:

\code{.cpp}
class MyClass
	: public IMessageListener  // it requires us to implement reference counting
	, public DefaultRefCounted
{
public:
	// Tell the compiler where the implementation is
	using DefaultRefCounted::AddRef;
	using DefaultRefCounted::Release;
}
\endcode

## Objects

The most common reference counted class is the <tt>Object</tt> class. The interesting thing about it is that
it also provides a method for casting objects.

### Object casting

Classes that inherit from <tt>Object</tt> have a feature called <b>type casting</b>. Imagine you receive an <tt>Object*</tt>,
and you want to know if that object is actually an instance of <tt>cCreatureAnimal</tt>. How do you do it? With casts.

<tt>object_cast<T>(object)</tt> will return a <tt>T*</tt> if possible, or <tt>nullptr</tt> if the given object is not of that type.
For example
\code{.cpp}
void function(Object* object) 
{
	auto animal = object_cast<cCreatureAnimal>(object);
	if (animal) {
		// animal is a cCreatureAnimal* now
		animal->SetScale(2.5f);
	}
}
\endcode

### Implementing the Cast method

Whenever you inherit from <tt>Object</tt> (or any class that inherits from it) it is recommended to implement the <tt>Cast</tt> method.
Therefore, you will also have to declare a type for your class.
It is specially important if your class inherits from multiple base classes.

It's actually very easy, here is an example:

\code{.cpp}
// Header file
class MyClass
	: public Window
	, public IWinProc
{
public:
	// Tell the compiler where the implementation is
	using DefaultRefCounted::AddRef;
	using DefaultRefCounted::Release;

	static const uint32_t TYPE = id("MyClass");

	void* Cast(uint32_t type) const override;
}

// Source file
void* MyClass::Cast(uint32_t type) const 
{
	// First check your class
	if (type == MyClass::TYPE) return (MyClass*)type;
	
	// If not, let the base classes do their job:
	if (Window::Cast(type)) return Window::Cast(type);
	if (IWinProc::Cast(type)) return IWinProc::Cast(type);
	
	// If cannot be casted, return nullptr
	return nullptr;
}
\endcode
*/